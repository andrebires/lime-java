package org.limeprotocol;

import org.limeprotocol.security.Authentication;
import org.limeprotocol.security.Authentication.AuthenticationScheme;
import org.limeprotocol.util.UUIDUtils;

/**
 * Represents a client session with the server and its current state.
 */
public class Session extends Envelope {
    private SessionState state;
    private SessionEncryption[] encryptionOptions;
    private SessionEncryption encryption;
    private SessionCompression[] compressionOptions;
    private SessionCompression compression;
    private AuthenticationScheme[] schemeOptions;
    private AuthenticationScheme scheme;
    private Authentication authentication;
    private Reason reason;
    
    public Session() {
        // The session id is generated by the server
        super(UUIDUtils.empty());
    }

    /**
     * Gets the information or changes the state of a session.
     * Only the server can change the session state,
     * but the client can request the state tra
     */
    public SessionState getState() {
        return state;
    }

    /**
     * Sets the information or changes the state of a session.
     * Only the server can change the session state,
     * but the client can request the state tra
     */
    public void setState(SessionState state) {
        this.state = state;
    }

    /**
     * In cases where the client receives a session with
     * FAILED state, this property should provide more
     * details about the problem.
     */
    public Reason getReason() {
        return reason;
    }

    /**
     * Sets the reason.
     */
    public void setReason(Reason reason) {
        this.reason = reason;
    }

    /**
     * Gets the authentication data, related to the selected schema.
     * Information like password sent by the client or
     * roundtrip data sent by the server.
     */
    public Authentication getAuthentication() {
        return authentication;
    }

    /**
     * Sets the authentication data, related to the selected schema.
     * Information like password sent by the client or
     * roundtrip data sent by the server.
     */
    public void setAuthentication(Authentication authentication) {
        this.authentication = authentication;
    }

    /**
     * Gets the encryption options provided by
     * the server during the session negotiation.
     */
    public SessionEncryption[] getEncryptionOptions() {
        return encryptionOptions;
    }

    /**
     * Sets the encryption options provided by
     * the server during the session negotiation.
     */
    public void setEncryptionOptions(SessionEncryption[] encryptionOptions) {
        this.encryptionOptions = encryptionOptions;
    }

    /**
     * The encryption option selected for the session.
     * This property is provided by the client in the
     * negotiation and by the server in the confirmation
     * after that.
     */    
    public SessionEncryption getEncryption() {
        return encryption;
    }

    /**
     * The encryption option selected for the session.
     * This property is provided by the client in the
     * negotiation and by the server in the confirmation
     * after that.
     */
    public void setEncryption(SessionEncryption encryption) {
        this.encryption = encryption;
    }

    /**
     * Gets the compression option selected for the session.
     * This property is provided by the client in the
     * negotiation and by the server in the confirmation
     * after that.
     */
    public SessionCompression getCompression() {
        return compression;
    }

    /**
     * Sets the compression option selected for the session.
     * This property is provided by the client in the
     * negotiation and by the server in the confirmation
     * after that.
     */
    public void setCompression(SessionCompression compression) {
        this.compression = compression;
    }

    /**
     * Gets the list of available authentication schemas
     * for session authentication provided by the server.
     */
    public AuthenticationScheme[] getSchemeOptions() {
        return schemeOptions;
    }

    /**
     * Sets the list of available authentication schemas
     * for session authentication provided by the server.
     */
    public void setSchemeOptions(AuthenticationScheme[] schemeOptions) {
        this.schemeOptions = schemeOptions;
    }

    /**
     * Gets the authentication scheme option selected
     * for the session. This property must be present
     * if the property authentication is defined.
     */
    public AuthenticationScheme getScheme() {
        if (this.authentication != null) {
            return this.authentication.getAuthenticationScheme();
        }

        return null;
    }
    
    /**
     * Gets the compression options provided by the
     * server during the session negotiation.
     */
    public SessionCompression[] getCompressionOptions() {
        return compressionOptions;
    }
    
    /**
     * Sets the compression options provided by the
     * server during the session negotiation.
     */
    public void setCompressionOptions(SessionCompression[] compressionOptions) {
        this.compressionOptions = compressionOptions;
    }

    /**
     * Defines the supported session states
     */
    public enum SessionState {
        /**
         * The session is new and doesn't exists an
         * ESTABLISHED context. It is sent by a client
         * node to start a session with a server.
         */
        NEW,

        /**
         * The server and the client are NEGOTIATING the
         * session options, like cryptography and compression.
         * The server sends to the client the options (if available)
         * and the client chooses the desired options.
         * If there's no options (for instance, if the connection
         * is already encrypted or the transport protocol doesn't
         * support these options), the server SHOULD skip the negotiation.
         */
        NEGOTIATING,

        /**
         * The session is being authenticated. The server sends to
         * the client the available authentication schemes list and
         * the client must choose one and send the specific authentication
         * data. The authentication can occurs in multiple roundtrips,
         * according to the selected schema.
         */
        AUTHENTICATING,

        /**
         * The session is active and is possible to send and receive
         * messages and commands. The server sends this state
         * after the session was authenticated.
         */
        ESTABLISHED,

        /**
         * The client node is requesting to
         * the server to finish the session.
         */
        FINISHING,

        /**
         * The session was gracefully
         * FINISHED by the server.
         */
        FINISHED,

        /**
         * A problem occurred while the session was ESTABLISHED, under
         * negotiation or authentication and it was closed by the server.
         * In this case, the property reason MUST be present to provide
         * more details about the problem.
         */
        FAILED
    }

    /**
     * Defines the valid session compression values.
     */
    public enum SessionCompression {
        /**
         * The session is not compressed.
         */
        NONE,
        /**
         * The session is using the GZip algorithm for compression.
         */
        GZIP
    }

    /**
     * Defines the valid session encryption values.
     */
    public enum SessionEncryption {
        /**
         * The session is not encrypted.
         */
        NONE,
        /**
         * The session is encrypted by TLS (Transport Layer Security).
         */
        TLS
    }
}
