package org.limeprotocol;

/// <summary>
/// Represents a client session with the
/// server and its current state
/// </summary>

import org.limeprotocol.security.Authentication;
import org.limeprotocol.security.Authentication.AuthenticationScheme;
import org.limeprotocol.util.UUIDUtils;

public class Session extends Envelope {
    public final String STATE_KEY = "state";
    public final String MODE_KEY = "mode";
    public final String ENCRYPTION_OPTIONS_KEY = "encryptionOptions";
    public final String ENCRYPTION_KEY = "encryption";
    public final String COMPRESSION_OPTIONS_KEY = "compressionOptions";
    public final String COMPRESSION_KEY = "compression";
    public final String SCHEME_OPTIONS_KEY = "schemeOptions";
    public final String SCHEME_KEY = "scheme";
    public final String AUTHENTICATION_KEY = "authentication";
    public final String REASON_KEY = "reason";

    public Session() {
        // The session id is generated by the server
        super(UUIDUtils.empty());
    }

    /// <summary>
    ///  Informs or changes the state of a session.
    ///  Only the server can change the session state,
    ///  but the client can request the state transition.
    /// </summary>
    public SessionState state;

    /// <summary>
    /// encryption options provided by
    /// the server during the session negotiation.
    /// </summary>
    public SessionEncryption[] encryptionOptions;

    /// <summary>
    /// The encryption option selected for the session.
    /// This property is provided by the client in the
    /// negotiation and by the server in the confirmation
    /// after that.
    /// </summary>

    public SessionEncryption encryption;

    /// <summary>
    /// Compression options provided by the
    /// server during the session negotiation.
    /// </summary>

    public SessionCompression[] compressionOptions;

    /// <summary>
    /// The compression option selected for the session.
    /// This property is provided by the client in the
    /// negotiation and by the server in the confirmation
    /// after that.
    /// </summary>

    public SessionCompression compression;

    /// <summary>
    /// List of available authentication schemas
    /// for session authentication provided by the server.
    /// </summary>

    public AuthenticationScheme[] schemeOptions;

    /// <summary>
    /// The authentication scheme option selected
    /// for the session. This property must be present
    /// if the property authentication is defined.
    /// </summary>
    public AuthenticationScheme scheme;

    /// <summary>
    /// authentication data, related to the selected schema.
    /// Information like password sent by the client or
    /// roundtrip data sent by the server.
    /// </summary>
    public Authentication authentication;

    /// <summary>
    /// In cases where the client receives a session with
    /// failed state, this property should provide more
    /// details about the problem.
    /// </summary>
    public Reason Reason;

    public SessionState getState() {
        return state;
    }

    public void setState(SessionState state) {
        this.state = state;
    }

    public Reason getReason() {
        return Reason;
    }

    public void setReason(Reason reason) {
        Reason = reason;
    }

    public Authentication getAuthentication() {
        return authentication;
    }

    public void setAuthentication(Authentication authentication) {
        this.authentication = authentication;
    }

    public SessionEncryption[] getEncryptionOptions() {
        return encryptionOptions;
    }

    public void setEncryptionOptions(SessionEncryption[] encryptionOptions) {
        this.encryptionOptions = encryptionOptions;
    }

    public SessionEncryption getEncryption() {
        return encryption;
    }

    public void setEncryption(SessionEncryption encryption) {
        this.encryption = encryption;
    }

    public SessionCompression getCompression() {
        return compression;
    }

    public void setCompression(SessionCompression compression) {
        this.compression = compression;
    }

    public AuthenticationScheme[] getSchemeOptions() {
        return schemeOptions;
    }

    public void setSchemeOptions(AuthenticationScheme[] schemeOptions) {
        this.schemeOptions = schemeOptions;
    }

    public AuthenticationScheme getScheme() {
        if (this.authentication != null) {
            return this.authentication.getAuthenticationScheme();
        }

        return null;
    }

    /// <summary>
    /// Defines the supported session states
    /// </summary>
    public enum SessionState {
        /// <summary>
        /// The session is new and doesn't exists an
        /// established context. It is sent by a client
        /// node to start a session with a server.
        /// </summary>

        New,
        /// <summary>
        /// The server and the client are negotiating the
        /// session options, like cryptography and compression.
        /// The server sends to the client the options (if available)
        /// and the client chooses the desired options.
        /// If there's no options (for instance, if the connection
        /// is already encrypted or the transport protocol doesn't
        /// support these options), the server SHOULD skip the negotiation.
        /// </summary>

        Negotiating,
        /// <summary>
        /// The session is being authenticated. The server sends to
        /// the client the available authentication schemes list and
        /// the client must choose one and send the specific authentication
        /// data. The authentication can occurs in multiple roundtrips,
        /// according to the selected schema.
        /// </summary>

        Authenticating,
        /// <summary>
        /// The session is active and is possible to send and receive
        /// messages and commands. The server sends this state
        /// after the session was authenticated.
        /// </summary>

        Established,
        /// <summary>
        /// The client node is requesting to
        /// the server to finish the session.
        /// </summary>

        Finishing,
        /// <summary>
        /// The session was gracefully
        /// finished by the server.
        /// </summary>

        Finished,
        /// <summary>
        /// A problem occurred while the session was established, under
        /// negotiation or authentication and it was closed by the server.
        /// In this case, the property reason MUST be present to provide
        /// more details about the problem.
        /// </summary>

        Failed
    }
}
